# import rclpy
# import threading
# import sys
# import tty
# import termios

# from rclpy.node import Node
# from hqv_public_interface.msg import RemoteDriverDriveCommand
# from std_msgs.msg import String


# class SubscriberNode(Node):

#     def __init__(self):
#         super().__init__('subscriber_node')
#         self.subscription = self.create_subscription(
#             String,
#             '/hqv_mower/gnss/position',
#             self.listener_callback,
#             10)  # queue size

#     def listener_callback(self, msg):
#         self.get_logger().info(f'Received: {msg.data}')

# def main(args=None):
#     rclpy.init(args=args)
    
#     sub_node = SubscriberNode()
    
#     #thread = threading.Thread(target=thread_function, args=(keyboard_remote_drive,))
#     #thread.start()
#     print("hjjjj")
#     i=0
#     while True:
#         rclpy.spin_once(sub_node)

#     sub_node.destroy_node()
#     rclpy.shutdown()


# if __name__ == '__main__':
#     main()


import rclpy
import time
from rclpy.node import Node
from hqv_public_interface.msg import RemoteDriverDriveCommand

class TimedRobotController(Node):

    def __init__(self):
        super().__init__('timed_robot_controller')
        self.drive_publisher = self.create_publisher(RemoteDriverDriveCommand, '/hqv_mower/remote_driver/drive', 100)

        # Movement parameters
        self.forward_duration = 5.0  # Seconds
        self.backward_duration = 5.0  # Seconds
        self.speed = 0.5  # Adjust this for your robot's speed

    def move_forward(self):
        msg = self.create_drive_command(self.speed, 0.0)
        self.drive_publisher.publish(msg)

    def move_backward(self):
        msg = self.create_drive_command(-self.speed, 0.0)
        self.drive_publisher.publish(msg)

    def stop(self):
        msg = self.create_drive_command(0.0, 0.0)
        self.drive_publisher.publish(msg)

    def create_drive_command(self, speed, steering):
        msg = RemoteDriverDriveCommand()
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.speed = speed
        msg.steering = steering
        return msg

    def run_sequence(self):
        # Move forward
        self.move_forward()
        start_time = self.get_clock().now().nanoseconds
        while (self.get_clock().now().nanoseconds - start_time) / 1e9 < self.forward_duration:
            rclpy.spin_once(self) 

        # Stop
        self.stop()

        # Move backward
        self.move_backward()
        start_time = self.get_clock().now().nanoseconds
        while (self.get_clock().now().nanoseconds - start_time) / 1e9 < self.backward_duration:
            rclpy.spin_once(self) 

        # Stop again 
        self.stop()


def main(args=None):
    rclpy.init(args=args)
    controller = TimedRobotController()
    controller.run_sequence()

    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()